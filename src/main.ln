type Token.Kind {
    EOF, Error, Identifier, Number, String,
    Plus, Minus, Star, Slash, Equal,
    LParen, RParen, LBrace, RBrace,
    Comma, Colon, Semicolon
}

type Token {
    kind   Token.Kind
    lexeme u8[]
}

type Lexer {
    source u8[:0]
    cursor u8
    line   int
    col    int
}

func new_lexer(source u8[:0]) Lexer {
    return Lexer(source, 0, 1, 1)
}

func lex(lexer Lexer) Token {
    
}

proc main() int {

    return 0
}





type Kind {
    Plus
    Minus
    PlusPlus
    MinusMinus
}

type Token {
    kind   Kind
    lexeme u8[]
}

type Lexer {
    text   u8[:0]
    cursor u8
}

type State {
    Start
    Plus
    Minus
}

func next({cursor, text} Lexer) Token {
/*
    var start = cursor
    var nesting = 0

    for i, c in text[cursor..] {
        match state {
            Start:
                start = cursor + i
                match c {
                    'a'..'z':
                    'A'..'Z':
                    '_':
                          state = Identifier
                    '0'..'9':
                          state = Number
                    '\'': state = SingleQuote
                    '"':  state = DoubleQuote
                    '=':  state = Equal
                    '<':  state = AngleBracketLeft
                    '>':  state = AngleBracketRight
                    '*':  state = Asterisk
                    '/':  state = Slash
                    '%':  state = Percent
                    '+':  state = Plus
                    '-':  state = Minus
                    '&':  state = Ampersand
                    '|':  state = Pipe
                    '^':  state = Caret
                    '.':  state = Dot
                    ' ': 
                    '\t': 
                        start += 1
                        continue
                    '\n':
                    '\r':
                        cursor = cursor + i + 1
                        return Token(Newline, text[start .. cursor])
                    '{':
                        cursor = cursor + i + 1
                        return Token(LBrace, text[start .. cursor])
                    '}':
                        cursor = cursor + i + 1
                        return Token(RBrace, text[start .. cursor])
                    '[':
                        cursor = cursor + i + 1
                        return Token(LBracket, text[start .. cursor])
                    ']':
                        cursor = cursor + i + 1
                        return Token(RBracket, text[start .. cursor])
                    '(':
                        cursor = cursor + i + 1
                        return Token(LParen, text[start .. cursor])
                    ')':
                        cursor = cursor + i + 1
                        return Token(RParen, text[start .. cursor])
                    ':':
                        cursor = cursor + i + 1
                        return Token(Colon, text[start .. cursor])
                    ',': 
                        cursor = cursor + i + 1
                        return Token(Comma, text[start .. cursor])
                    ';':
                        cursor = cursor + i + 1
                        return Token(Semicolon, text[start .. cursor])
                    '~':
                        cursor = cursor + i + 1
                        return Token(Tilde, text[start .. cursor])
                    0:
                        cursor = cursor + i
                        return Token(Eof, text[start .. cursor])
                    else:
                        cursor = cursor + i + 1
                        return Token(Invalid, text[start .. cursor])
                }

            Identifier:
                match c {
                    'a'..'z':
                    'A'..'Z':
                    '0'..'9':
                    '_':
                        continue
                    else:
                        cursor = cursor + i
                        lexeme = text[start .. cursor]
                        return Token(match_keyword(lexeme), lexeme)
                }

            Number:
                match c {
                    '0'..'9': continue
                    else:
                        cursor = cursor + i
                        return Token(Number, text[start .. cursor])
                }

            SingleQuote:
                match c {
                    '\\':
                        continue
                    '\'':
                        cursor = cursor + i + 1
                        return Token(StringLiteral, text[start .. cursor])
                    else:
                        continue
                }

            DoubleQuote:
                match c {
                    '"':
                        cursor = cursor + i + 1
                        return Token(StringLiteral, text[start + 1 .. cursor - 1])
                    else:
                        continue
                }

            Equal:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(EqualEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Equal, text[start .. cursor])
                }

            AngleBracketLeft:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AngleBracketLeftEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(AngleBracketLeft, text[start .. cursor])
                }

            AngleBracketRight:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AngleBracketRightEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(AngleBracketRight, text[start .. cursor])
                }

            Asterisk:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AsteriskEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Asterisk, text[start .. cursor])
                }

            Percent:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(PercentEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Percent, text[start .. cursor])
                }

            Plus:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(PlusEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Plus, text[start .. cursor])
                }

            Minus:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(MinusEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Minus, text[start .. cursor])
                }

            Ampersand:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AmpersandEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Ampersand, text[start .. cursor])
                }

            Pipe:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(PipeEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Pipe, text[start .. cursor])
                }

            Caret:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(CaretEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Caret, text[start .. cursor])
                }

            Dot:
                match c {
                    '.': state = DotDot
                    else:
                        cursor = cursor + i
                        return Token(Dot, text[start .. cursor])
                }

            DotDot:
                match c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(DotDotEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(DotDot, text[start .. cursor])
                }

            Slash:
                match c {
                    '/':
                        state = LineComment
                    '*':
                        state = MultilineComment
                        nesting = 1
                    '=':
                        cursor = cursor + i + 1
                        return Token(SlashEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Slash, text[start .. cursor])
                }

            LineComment:
                match c {
                    '\n':
                    '\r':
                    0:
                        cursor = cursor + i
                        return Token(LineComment, text[start .. cursor])
                    else:
                        continue
                }

            MultilineComment:
                if c == '/' and text[cursor + i + 1] == '*' {
                    nesting += 1
                } else if c == '*' and text[cursor + i + 1] == '/' {
                    nesting -= 1
                    if nesting == 0 {
                        cursor = cursor + i + 2
                        return Token(MultilineComment, text[start .. cursor])
                    }
                } else if c == 0 {
                    cursor = cursor + i
                    return Token(MultilineComment, text[start .. cursor])
                }
        }
    }
*/
    // End of file fallback


    

    return Token(Eof, text[cursor .. cursor])
}