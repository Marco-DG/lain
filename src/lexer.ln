type Kind {
    Invalid
    Eof
    Newline
    Identifier
    Number
    StringLiteral
    LParen
    RParen
    LBracket
    RBracket
    LBrace
    RBrace
    Dot
    DotDot
    DotDotEqual
    Comma
    Colon
    Semicolon
    Tilde
    Equal
    EqualEqual
    AngleBracketLeft
    AngleBracketLeftEqual
    AngleBracketRight
    AngleBracketRightEqual
    Asterisk
    AsteriskEqual
    Slash
    SlashEqual
    Plus
    PlusEqual
    Minus
    MinusEqual
    Ampersand
    AmpersandEqual
    Pipe
    PipeEqual
    Caret
    CaretEqual
    Percent
    PercentEqual
    LineComment
    MultilineComment
    KeywordIf
    KeywordMov
    KeywordEnd
    KeywordFor
    KeywordType
    KeywordFunc
    KeywordProc
    KeywordExpr
    KeywordElif
    KeywordElse
    KeywordCase
    KeywordMacro
    Keywordswitch
    KeywordImport
    KeywordExport
}

type Token {
    kind   Kind
    lexeme u8[]
}

type Lexer {
    text   u8[:0]
    cursor u8
}

type State {
    Start
    Identifier
    Number
    SingleQuote
    DoubleQuote
    LineComment
    MultilineComment
    Equal
    AngleBracketLeft
    AngleBracketRight
    Asterisk
    Slash
    Percent
    Plus
    Minus
    Ampersand
    Pipe
    Caret
    Dot
    DotDot
}

func switch_keyword(lexeme u8[]) Kind {
    switch lexeme {
        "if"    :   return KeywordIf
        "end"   :   return KeywordEnd
        "for"   :   return KeywordFor
        "mov"   :   return KeywordMov
        "type"  :   return KeywordType
        "func"  :   return KeywordFunc
        "proc"  :   return KeywordProc
        "expr"  :   return KeywordExpr
        "elif"  :   return KeywordElif
        "else"  :   return KeywordElse
        "case"  :   return KeywordCase
        "macro" :   return KeywordMacro
        "switch" :   return Keywordswitch
        "import":   return KeywordImport
        "export":   return KeywordExport
        else    :   return Identifier
    }
}

func next(lexer Lexer) Token {
    use lexer.cursor as cursor
    use lexer.text as text

    var start = cursor
    var state = Start
    var nesting = 0

    for i, c in text[cursor..] {
        switch state {
            Start:
                start = cursor + i
                switch c {
                    'a'..'z':
                    'A'..'Z':
                    '_':
                          state = Identifier
                    '0'..'9':
                          state = Number
                    '\'': state = SingleQuote
                    '"':  state = DoubleQuote
                    '=':  state = Equal
                    '<':  state = AngleBracketLeft
                    '>':  state = AngleBracketRight
                    '*':  state = Asterisk
                    '/':  state = Slash
                    '%':  state = Percent
                    '+':  state = Plus
                    '-':  state = Minus
                    '&':  state = Ampersand
                    '|':  state = Pipe
                    '^':  state = Caret
                    '.':  state = Dot
                    ' ': 
                    '\t': 
                        start += 1
                        continue
                    '\n':
                    '\r':
                        cursor = cursor + i + 1
                        return Token(Newline, text[start .. cursor])
                    '{':
                        cursor = cursor + i + 1
                        return Token(LBrace, text[start .. cursor])
                    '}':
                        cursor = cursor + i + 1
                        return Token(RBrace, text[start .. cursor])
                    '[':
                        cursor = cursor + i + 1
                        return Token(LBracket, text[start .. cursor])
                    ']':
                        cursor = cursor + i + 1
                        return Token(RBracket, text[start .. cursor])
                    '(':
                        cursor = cursor + i + 1
                        return Token(LParen, text[start .. cursor])
                    ')':
                        cursor = cursor + i + 1
                        return Token(RParen, text[start .. cursor])
                    ':':
                        cursor = cursor + i + 1
                        return Token(Colon, text[start .. cursor])
                    ',': 
                        cursor = cursor + i + 1
                        return Token(Comma, text[start .. cursor])
                    ';':
                        cursor = cursor + i + 1
                        return Token(Semicolon, text[start .. cursor])
                    '~':
                        cursor = cursor + i + 1
                        return Token(Tilde, text[start .. cursor])
                    0:
                        cursor = cursor + i
                        return Token(Eof, text[start .. cursor])
                    else:
                        cursor = cursor + i + 1
                        return Token(Invalid, text[start .. cursor])
                }

            Identifier:
                switch c {
                    'a'..'z':
                    'A'..'Z':
                    '0'..'9':
                    '_':
                        continue
                    else:
                        cursor = cursor + i
                        lexeme = text[start .. cursor]
                        return Token(switch_keyword(lexeme), lexeme)
                }

            Number:
                switch c {
                    '0'..'9': continue
                    else:
                        cursor = cursor + i
                        return Token(Number, text[start .. cursor])
                }

            SingleQuote:
                switch c {
                    '\\':
                        continue
                    '\'':
                        cursor = cursor + i + 1
                        return Token(StringLiteral, text[start .. cursor])
                    else:
                        continue
                }

            DoubleQuote:
                switch c {
                    '"':
                        cursor = cursor + i + 1
                        return Token(StringLiteral, text[start + 1 .. cursor - 1])
                    else:
                        continue
                }

            Equal:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(EqualEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Equal, text[start .. cursor])
                }

            AngleBracketLeft:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AngleBracketLeftEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(AngleBracketLeft, text[start .. cursor])
                }

            AngleBracketRight:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AngleBracketRightEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(AngleBracketRight, text[start .. cursor])
                }

            Asterisk:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AsteriskEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Asterisk, text[start .. cursor])
                }

            Percent:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(PercentEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Percent, text[start .. cursor])
                }

            Plus:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(PlusEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Plus, text[start .. cursor])
                }

            Minus:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(MinusEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Minus, text[start .. cursor])
                }

            Ampersand:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(AmpersandEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Ampersand, text[start .. cursor])
                }

            Pipe:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(PipeEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Pipe, text[start .. cursor])
                }

            Caret:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(CaretEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Caret, text[start .. cursor])
                }

            Dot:
                switch c {
                    '.': state = DotDot
                    else:
                        cursor = cursor + i
                        return Token(Dot, text[start .. cursor])
                }

            DotDot:
                switch c {
                    '=':
                        cursor = cursor + i + 1
                        return Token(DotDotEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(DotDot, text[start .. cursor])
                }

            Slash:
                switch c {
                    '/':
                        state = LineComment
                    '*':
                        state = MultilineComment
                        nesting = 1
                    '=':
                        cursor = cursor + i + 1
                        return Token(SlashEqual, text[start .. cursor])
                    else:
                        cursor = cursor + i
                        return Token(Slash, text[start .. cursor])
                }

            LineComment:
                switch c {
                    '\n':
                    '\r':
                    0:
                        cursor = cursor + i
                        return Token(LineComment, text[start .. cursor])
                    else:
                        continue
                }

            MultilineComment:
                if c == '/' and text[cursor + i + 1] == '*' {
                    nesting += 1
                } else if c == '*' and text[cursor + i + 1] == '/' {
                    nesting -= 1
                    if nesting == 0 {
                        cursor = cursor + i + 2
                        return Token(MultilineComment, text[start .. cursor])
                    }
                } else if c == 0 {
                    cursor = cursor + i
                    return Token(MultilineComment, text[start .. cursor])
                }
        }
    }

    // End of file fallback
    return Token(Eof, text[cursor .. cursor])
}